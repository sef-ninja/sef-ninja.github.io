<html>
  <head>
    <title>Securing APIs LnL Notes</title>
    <style>
        h1, h2, li, p {
            font-family: "Segoe UI",Arial,sans-serif;
            font-style: normal;
        }
    </style>
  </head>
  <body>
    <img src="../logo.png"></img><br />
    <h1>Securing APIs LnL Notes</h1>

    <h2>Overview</h2>
    <ul>
	  <li>Possible Title:  Tokens! Securing APIs for Single-Page Apps with JWT and OAuth 2</li>
      <li>Possible Title:  Securing APIs for Single-Page Apps with JWT and OAuth 2</li>
      <li>Possible Title:  Securing APIs: Token-Based Authentication with OAuth 2</li>
      <li>Possible Title:  Securing REST APIs: Token-Based Authentication</li>
      <li>Possible Title:  Token-Based Authentication for Securing APIs</li>
      <li>Securing distributed systems</li>
      <li>A few different types (HTTP Basic over TLS, NTLM, OAuth 2)</li>
	  <li>Securing microservices with OAuth 2 (We don't want to require each service to have a request handler for authentication/authorization.  Overview diagram of how implicit flow works)</li>
      <li>Demo: OAuth 2.0 Implicit Grant Flow using JWT Access Tokens using Node.js and Java</li>
    </ul>
	<p><img src="images/oauth2_implicit_flow.png"></img></p>
	
	<h2>Resources</h2>
    <ul>
    	<li><a href="https://dzone.com/articles/api-security-ways-to-authenticate-and-authorize">Securing APIs</a></li>
		<li><a href="https://beku8.wordpress.com/2015/03/31/configuring-spring-oauth2-with-jwt-asymmetric-rsa-keypair/">Spring OAuth2: JWT with RSA Asymmetric Key Pair</a></li>
		<li><a href="https://labs.hybris.com/2012/06/05/oauth2-the-implicit-flow-aka-as-the-client-side-flow/">Good article about Implicit Flow</a></li>
		<li><a href="https://dev.clever.com/instant-login/implicit-grant-flow">Good description of Implicit Grant Flow</a></li>
    	<li><a href="https://stormpath.com/blog/the-ultimate-guide-to-mobile-api-security">Mobile API Security</a></li>
		<li><a href="https://scotch.io/tutorials/the-ins-and-outs-of-token-based-authentication">The Ins and Outs of Token Based Authentication</a></li>
    	<li><a href="http://www.asp.net/aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server">OWIN OAuth 2 Authorization Server Tutorial</a></li>
    </ul>
	
	<h2>JWT Articles</h2>
	<ul>
	   <li><a href="https://stormpath.com/blog/nodejs-jwt-create-verify">Create and Verify JWTs with Node.js</a></li>
	   <li><a href="https://ponyfoo.com/articles/json-web-tokens-vs-session-cookies">JWTs vs Session Cookies</a></li>
       <li><a href="https://stormpath.com/blog/token-authentication-scalable-user-mgmt">Token Authentication</a></li>
       <li><a href="https://www.mobomo.com/2013/11/json-web-token-the-useful-little-standard-you-haven-t-heard-about/">JSON Web Tokens</a></li>
       <li><a href="https://www.jsonwebtoken.io/">JWT Encoder</a></li>
       <li><a href="http://bitoftech.net/2014/10/27/json-web-token-asp-net-web-api-2-jwt-owin-authorization-server/">Web Api JWT Auth Server</a></li>
       <li><a href="http://self-issued.info/docs/draft-jones-json-web-token-01.html#anchor3">Good JWT Overview</a></li>
       <li><a href="http://jarbytes.com/jwt-on-dropwizard.html">JWT on Dropwizard</a></li>
	</ul>

	<h2>Additional Articles</h2>
    <ul>
	  <li><a href="https://en.wikipedia.org/wiki/Federated_identity">Federated Identity</a></li>
      <li><a href="http://www.baeldung.com/spring-security-oauth-jwt">Good Spring Security JWT Tutorial with code</a></li>
      <li><a href="https://www.youtube.com/watch?v=USMl2GNg2r0">Good talk about securing microservices</a></li>
      <li><a href="http://nordicapis.com/how-to-control-user-identity-within-microservices/">How to Control User Identity Within Microservices</a><br /></li>
      <li><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">Good introduction to OAuth2</a></li>
      <li><a href="https://spring.io/blog/2015/02/03/sso-with-oauth2-angular-js-and-spring-security-part-v">OAuth2 Authorization Server in Spring</a></li>
      <li><a href="http://www.asp.net/aspnet/overview/owin-and-katana/owin-oauth-20-authorization-server">OAuth2 Authorization Server in OWIN</a></li>
      <li><a href="http://connect2id.com/learn/openid-connect">Good OpenID Connect explanation</a></li>
    </ul>
	
	<h2>Topics</h2>
	<ul>
	  <li>The purpose of the token is to make it unnecessary for the resource owner to share its credentials with the client.</li>
	  <li>Denver/UberConf overview (Talks by Brian Sletten: Identity, Privilege)</li>
	  <li>Identity, Federated Identity</li>
	  <li>HTTP Basic alone is not secure</li>
	  <li>Privilege</li>
	  <li><a href="https://en.wikipedia.org/wiki/Confused_deputy_problem">Confused Deputy Problem</a>, and compiler system privilege example from Privilege talk at UberConf 2016</li>
	  <li><a href="https://msdn.microsoft.com/en-us/library/dn568102.aspx">Valet Key Pattern</a>.  <a href="https://hueniverse.com/oauth/guide/intro/">Blog</a> describing the valet key metaphor.  This is another <a href="http://apigee.com/about/blog/technology/oauth-valet-key-metaphor">article</a> that describes the valet key metaphor, where the token is like the valet key.</li>
	  <li>Microservices</li>
	  <li>TLS is more secure than SSL</li>
	  <li>Token-based authentication</li>
	  <li>Using tokens in the place of session IDs</li>
	  <li>It is not secure to store API keys in your JavaScript.  With a JavaScript app all requests come from the client which is the same place where all the code is stored which means if you store your API key in a JavaScript web app you might as well just print it out in big bold letters across the homepage as the whole world now has access to it through their browser’s dev tools.</li>
	  <li>Oauth 2 is not an authentication protocol, and it is not an authorization protocol.  It is a delegation protocol (Include power-of-attorney analogy) (podcast: The user delegates access to app so that it can access resources.  The resource server can still reject the request!!)</li>
	  <li>One of the main goals of OAuth 2:  Give the client access to the protected resource on behalf of the resource owner.</li>
	  <li>OAuth 2 description (from the spec):  The OAuth 2.0 authorization framework enables a third-party application to obtain limited access to an HTTP service, either on behalf of a resource owner by orchestrating an approval interaction between the resource owner and the HTTP service, or by allowing the third-party application to obtain access on its own behalf.</li>
	  <li>Explain how OAuth 2 is different than typical client-server authorization.  See <a href="https://hueniverse.com/oauth/guide/intro/">this article</a>.</li>
	  <li>Stateless authentication with OAuth 2 and JWT</li>
	  <li>Stateless tokens</li>
	  <li>JWT / JOSE</li>
	  <li>JWT signing by Authorization Server (OAuth server) using private key.  Resource server can verify access token is valid.</li>
	  <li>JWT works by simply encoding a string made up of a small JSON object and hashing it using a secret shared between the two parties. The algorithm is configurable, but is usually HMAC SHA-256.</li>
	  <li>Passport???</li>
	  <li>Security issues with storing API key in JavaScript</li>
	  <li>Token-based credentials provide higher entropy and a more secure form of authentication and authorization than Username Password Credentials</li>
	  <li>Scopes are granted by the Authorization Server and stored in an access token.</li>
	  <li>With token-based credentials, the Identity Provider issues tokens based on an initial authentication request with username/password credentials. From then on, the app only has to send the token.</li>
	  <li>Tokens are generated for your users after they present verifiable credentials.  The initial authentication could be by username/password credentials, API keys or even tokens from another service.</li>
	  <li>Once generated, the token is attached to the user via a browser cookie or saved in local/session storage.</li>
	  <li>Using tokens in a mobile app allow you to easily and securely control which mobile devices are accessing your API.</li>
	  <li> A JWT is a compact, URL-safe, encryptable JSON object that is rapidly becoming the standard for token implementation across the web.</li>
	  <li>Libraries used by teams:  System.IdentityModel.Tokens.Jwt</li>
	  <li><a href="http://passportjs.org/">Passport</a> for front-end OAuth 2</li>
	  <li>OAuth 2 in Action, Chapter 11 "OAuth Tokens" contains a good description of the different types of tokens such as tokens that act like a handle to information in a database, and structured tokens like JWTs.</li>
	</ul>

    <h2>The AS can issue single access token for multiple RS's!</h2>
    <p>Assuming your system has a single AS, the scopes concept allows you to handle multiple RS's.  You could define a scope per API and have clients ask for one or both scopes.  Access tokens are issued on a per-client basis, so handing out different access tokens to the same client doesn't bring you any security advantage unless the two APIs are controlled by different entities.</p>

    <h2>JSON Web Tokens (JWTs or "jots")</h2>
    <ul>
    	<li>The signature is calculated by base64url encoding the header and payload, concatenating them with a period as a separator, and digitally signing the result.  The signature is then base64Url encoded and appended to the end (after the last period).</li>
    </ul>

    <h2>JWTs and Stateless Authentication</h2>
    <p>In authentication, when the user successfully logs in using their credentials, a JWT will be returned and must be saved locally, instead of the traditional approach of creating a session in the server and returning a cookie.</p>
    <p>Whenever the user wants to access a protected resource, the user agent should send the JWT, typically in the Authorization header using the Bearer schema.</p>
    <p>This is a stateless authentication mechanism as the user state is never saved in server memory.  This allows you to fully rely on data APIs that are stateless and that even make requests to downstream services.</p>

	<h2>Implicit Grant Flow</h2>
	<ul>
		<li>The redirect_uri should match the redirect URI that was originally specified when registering the client.</li>
		<li>The AS redirects the RO's browser to another destination (via HTTP 302 Found).</li>
		<li>To protect against the "confused deputy problem" and determine if the token is intended for your application and was produced by the other distributed application, you must verify its authenticity and legitimacy by issuing an additional request to the other distributed application.  See <a href="https://dev.clever.com/instant-login/implicit-grant-flow">this article</a>.</li>
		<li>In the Implicit Grant type, the client is running within the browser.</li>
		<li>See Chapter 6 in OAuth 2 in Action</li>
	</ul>

    <h2>Implicit Grant Flow Sequence Diagram</h2>
    <ul>
        <li>Include vertical lines for:  Client, AS, RS</li>
        <li>Add RO (cartoon user) to left of sequence diagram</li>
        <li>Under RO, include a rectangle that represents current state of the user agent (browser)</li>
    	<li>Explicitly state that the client asks for a scope or multiple scopes!</li>
    </ul>

	<h2>Identity</h2>
	<ul>
	  <li>The Identity Store (for example Active Directory) contains the user data.  An Identity Provider is a service that exposes this information.</li>
	  <li>When each service has its own request handler for performing authentication and authorization, it means each service is acting as an Identity Provider, rather than using a single Identity Provider service.  This violates the Single Responsibility Principle.</li>
	</ul>
	
	<h2>Principle of Least Privilege</h2>
	<ul>
		<li>Present overview.  Give example of service representative only being allowed to access customer data for the duration of the phone call.</li>
		<li>OAuth 2.0 Scopes:   Something like EMAIL_SERVICE is too generic.  It means the user is given too much authority.</li>
		<li>OAuth 2.0 Scopes:   More fine-grained (EMAIL_READ, EMAIL_DELETE, EMAIL_POST, EMAIL_MOVE, etc.) allows clients to use minimal authority to access the user's mailbox without requiring full access.  The core functionality of your service can be expressed as scopes!!</li>
		<li>Allow a client to do something on the RO's behalf, without providing personally identifiable information to the client.</li>
	</ul>

	<h2>Slides</h2>
	<ul>
	  <li>Overview</li>
	  <li>UberConf 2016 overview (security, microservices, etc.)</li>
	  <li>What is Token-Based Authentication?</li>
	  <li>Securing APIs (Overview of options for securing APIs)</li>
	  <li>What is OAuth 2.0? (definition from spec, valet key metaphor, etc.)</li>
	  <li>OAuth 2.0:  Include content from Ch. 11!!  (The client does not need to know anything about the token itself...)  (OAuth 2 does not specify the token format...  It provides flexibility!!)</li>
	  <li>Securing APIs for Single Page Apps (Implicit Grant flow)</li>
	  <li>Implicit Grant Flow Sequence Diagram</li>
	  <li>Slide discussing query parameters (response_type=token, client_id, redirect_uri, scope, state).  See <a href="https://labs.hybris.com/2012/06/05/oauth2-the-implicit-flow-aka-as-the-client-side-flow/">this article</a>.</li>
	  <li>JSON Web Tokens (arcade token visuals, etc.)</li>
	  <li>JSON Web Tokens (Create nice diagram of header, payload, and signature.  Show how signature is base64Url-encoded and appended to the end.  Mention:  The output is three Base64 strings separated by dots that can be easily passed in HTML and HTTP environments, while being more compact when compared to XML-based standards such as SAML.)</li>
	  <li>JSON Web Tokens (Demo of jwt.io Debugger)</li>
	  <li>Lunch (Distributed) System Data-Flow Diagram</li>
	  <li>Demo</li>
	</ul>
	
	<h2>Demo</h2>
	<ul>
	  <li>OAuth 2.0 Implicit Grant Flow</li>
	  <li>JWT Access Tokens</li>
	  <li>Spring Boot is an application-bootstrapping framework that helps with the creation of Spring based applications with no necessary XML configuration or code generation.</li>
	  <li>Spring Security OAuth 2 Authorization Server</li>
	  <li>Resource Server (Lunch Items REST API):  C# or Node.js</li>
	  <li>AngularJS/sass/materialize??? client</li>
	  <li>User as the Resource Owner</li>
	  <li>In Implicit Grant Flow, the client secret is not used, as it cannot be kept confidential by a JavaScript app running in the browser.  (Can be decompiled, source code inspected, etc..)</li>
	</ul>
	<p>First, implement node.js/express.js Implicit Grant Flow example from OAuth 2 in Action, and then modify it to use the Spring Boot Authorization Server (AS) to issue JWT access tokens.</p>
	
    <h2>Slides: Interesting Visuals</h2>
    <ul>
      <li>Because tokens are so important in OAuth, the unofficial OAuth <a href="images/oauth_logo.png">logo</a> is modeled after a <a href="images/bus_token.jpg">bus token</a>.  (See OAuth 2 in Action, "11.1 What are OAuth Tokens?")</li>
      <li>Tokens for arcade games... (Include .mp3 of 80's ambient arcade noise?  Include game cabinets image.  Include token machine image and tokens image.).  Insert tokens in order to be granted limited access to the game.  You can play the game, but you cannot reset the high scores, etc..</li>
      <li>Slugs.  (Show electrical box image.)  Lore around my small school was that you could use slugs to trick the machine into letting you play the game.  It exploited a system vulnerability.  At an abstract level, you were forging an access token.  (Might use this to segue into JWT signing with private key so that the resource server knows the access token has not been forged...)</li>
      <li>Include an image of a luxury car and a car key.  OAuth 2 in Action describes the analogy of a the valet key, where a car owner can grant limited access to the vehicle.<li>
	  <li>Limited access as opposed to impersonating the resource owner.  When pairing, you will give your partner limited access to Outlook (like checking calendar for retro meeting), but you would not allow them to send emails impersonating you...</li>
    </ul>

    <h2>OAuth 2</h2>
    <p>OAuth 2 is an authorization framework that enables applications to obtain limited access to user accounts on an HTTP service, such as Facebook, GitHub, and DigitalOcean. It works by delegating user authentication to the service that hosts the user account, and authorizing third-party applications to access the user account. OAuth 2 provides authorization flows for desktop apps, web apps, and mobile apps.</p><br />
    
    <h2>OAuth's Four Main Actors</h2>
    <p>OAuth has four main actors:</p>
    <ul>
      <li>Resource Owner (RO): The user</li>
      <li>Client: The web or mobile app</li>
      <li>Authorization Server (AS): The OAuth 2.0 server</li>
      <li>Resource Server (RS): Server providing resources</li>
    </ul><br />

    <p>To better understand the OAuth 2.0 Framework, it is important to realize that the client communicates with the authorization server in two distinct ways: via the back channel and via the front channel. The back channel is the direct communication between the client and the token endpoint, whereas the front channel is the indirect communication between the client and the authorization endpoint via the user's agent and based on HTTP redirects. Therefore, the front channel has some significant limitations. Since it's based on redirects, it imposes restrictions on the HTTP features that can be used. The request method must be a GET, and the request information must be passed in the request URI, namely in the URI's query string.</p>

    <h2>Simplified Example of an OAuth 2 Flow</h2>
    <ol>
      <li>The Client requests access to the Resource Server by calling the Authorization Server.</li>
      <li>The Authorization Server redirects to allow the user to authenticate, which is usually performed within a browser. This is essentially signing into an authorization server, not the app.</li>
      <li>The Authorization Server then validates the user credentials and provides an Access Token to client, which can be used to call the Resource Server</li>
      <li>The Client then sends the Token to the Resource Server</li>
      <li>The Resource Server asks the Authorization Server if the token is valid.</li>
      <li>The Authorization Server validates the Token, returning relevant information to the Resource Server i.e. time till token expiration, who the token belongs to.</li>
      <li>The Resource Server then provides data to the Client.</li>
    </ol><br />

    <h2>OAuth 2.0 Spec Highlights</h2>
    <ul>
      <li><a href="https://tools.ietf.org/html/rfc6749#section-3.1.2">3.1.2 Redirection Endpoint</a></li>
    </ul>

    <h2>OAuth 2.0 Validating Tokens</h2>
    <ul>
    	<li>A very common OAuth deployment pattern is using a shared database for the AS and RS.</li>
    	<li>There’s a standardized web protocol called Token Introspection that the authorization server can offer, allowing the resource server to check the token’s state at runtime.</li>
    </ul>

    <h2>Protecting a web API with OAuth</h2>
    <p>Protecting a web API with OAuth is fairly straightforward:</p>
    <ul>
    	<li>The token gets parsed out of the incoming request.</li>
    	<li>The token is validated with the authorization server.</li>
    	<li>The response is served based on what the token is good for.</li>
    </ul>

	<h2>OAuth Scopes</h2>
	<p>Information about serving user-specific data can be found in the following section of OAuth 2 in Action: Different users for different data results.  In the demo project, resources (lunch items) can be associated with specific employeeId values!!  (This is a very powerful design pattern, as it can protect the resource owner’s privacy by not revealing personally identifying information unnecessarily.)</p>
	<p>A scope is a permission.</p>
    <ul>
      <li><a href="http://docs.apigee.com/api-services/content/working-scopes">apigee: Working with OAuth2 Scopes</a></li>
	  <li><a href="https://blogs.oracle.com/OracleIDM/entry/securing_access_with_oauth2_how">Article about OAuth2 scopes</a> (Also contains a good description of access tokens.)</li>
    </ul>
  
	<p>Figuring out what scopes to expose is a responsibility of an application developer, and it may be confusing at first:</p>
    <ul>
      <li>Do I expose a single scope protecting the entire service, or do I expose scopes to protect fine-grained business functionality of my application?</li>
      <li>Do I break up my service into many smaller services with one scope each, or do I build multi-functional service with multiple fine-grained scopes?</li>
      <li>How do I balance the needs of my clients to request specific capabilities and the needs of my application owners to manage appropriate policies?</li>
    </ul>
  	
	<h2>General OAuth 2 Resources</h2>
	<p><a href="https://api.slack.com/docs/oauth">Using OAuth 2.0 (Slack)</a></p>
	
	<h2>HMAC-SHA256</h2>
	<ul>
	  <li><a href="http://stackoverflow.com/questions/18687926/verifying-hmac-sha1-signature-in-java">Signature vs. HMAC</a></li>
	  <li>MACs differ from digital signatures as MAC values are both generated and verified using the same secret key. This implies that the sender and receiver of a message must agree on the same key before initiating communications, as is the case with symmetric encryption. For the same reason, MACs do not provide the property of non-repudiation offered by signatures specifically in the case of a network-wide shared secret key: any user who can verify a MAC is also capable of generating MACs for other messages. In contrast, a digital signature is generated using the private key of a key pair, which is asymmetric encryption. Since this private key is only accessible to its holder, a digital signature proves that a document was signed by none other than that holder. Thus, digital signatures do offer non-repudiation. However, non-repudiation can be provided by systems that securely bind key usage information to the MAC key; the same key is in possession of two people, but one has a copy of the key that can be used for MAC generation while the other has a copy of the key in a hardware security module that only permits MAC verification. This is commonly done in the finance industry.</li>
	  <li>in order to verify an HMAC, you need to share the key that was used to generate it. You would send the message, the HMAC, and the receiver would have the same key you used to generate the HMAC. They could then use the same algorithm to generate an HMAC from your message, and it should match the HMAC you sent. Public/private keys (assymetric) are not used for this. You need to generate a symmetric key (like AES) and securely share that with the people that will be generating/verifying the HMAC.</li>
	</ul>
	
	<h2>Blurb</h2>
	<ul>
	  <li>Learn techniques and technologies for guarding protected resources in systems composed of multiple distributed HTTP services.</li>
	</ul>
    </body>
</html>
