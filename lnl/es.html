<html>
  <head>
    <title>Event Sourcing LnL</title>
    <style>
        h1, h2, li, p {
            font-family: "Segoe UI",Arial,sans-serif;
            font-style: normal;
        }
    </style>
  </head>
  <body>
    <img src="../logo.png"></img><br />
    <h1>Event Sourcing LnL</h1>

    <h2>Slides</h2>
    <ul>
      <li>Overview</li>
      <li>TODO: What is event sourcing?</li>
      <li>Advantages</li>
      <li>Decomposing an application into services is challenging.  Difficult to decompose:  Decomposing your domain model,  Executing transactions across your services, Querying your services</li>
      <li>Good microservices rule of thumb:  Services do not share a database.  Advantages:  loose coupling, your service doesn't have to wait on locks from other services, Disadvantages: This functional decomposition of the database creates challenges with: data consistency, executing queries</li>
      <li>Transactions: Our goal is to maintain data consistency across our services, ACID, 2PC (distributed transactions), CAP Theorem</li>
      <li>Events slide:  Events happen in the past.  (Event data records things that happen rather than things that are.)</li>
      <li>Events slide:  Events are immutable. Because events happen in the past, they cannot be changed or undone. However, subsequent events may alter or negate the effects of earlier events.</li>
      <li>Events slide:  Events are one-way messages. Events have a single source (publisher) that publishes the event. One or more recipients (subscribers) may receive events.</li>
      <li>Events slide:  Typically, events include parameters that provide additional information about the event.</li>
      <li>Events slide:  In the context of event sourcing, events should describe business intent.</li>
      <li>A log: Append-only, Totally-ordered sequence of records, Ordered by time.  (Include diagram, [][][][][][] ...)</li>
      <li>Group Event-Sourcing Activity overview</li>
      <li>Group Event-Sourcing Activity rules</li>
      <li>State Machine Replication Principle (From Jay Kreps...  He talks about a log-centric approach to distributed systems...):  If two identical, deterministic processes begin in the same state and get the same inputs in the same order, they will produce the same output and end in the same state.</li>
      <li></li>
      <li>Slide showing difference between event-driven and API driven.  (See New York Times research for diagrams.)</li>
      <li>When creating an application using event sourcing, you need a store for the log of changes.  Kafka has already solved problems:  Immutable log, Computing "materialized views" off of the log.  (The New York Times does this...) 
      <li>Tradeoffs</li>
    </ul>

    <h2>Research</h2>
    <h3>Event Sourcing</h3>
    <ul>
      <li><a href="https://www.infoq.com/articles/microservices-aggregates-events-cqrs-part-1-richardson">Developing Transactional Microservices Using Aggregates, Event Sourcing and CQRS - Part 1</a></li>
      <li><a href="https://initiate.andela.com/event-sourcing-and-cqrs-a-look-at-kafka-e0c1b90d17d8">ES, CQRS, and Kafka</a></li>
      <li><a href="https://msdn.microsoft.com/en-us/library/jj591559.aspx">Introducing Event Sourcing</a></li>
      <li><a href="http://www.continuousimprover.com/2017/02/the-good-of-event-sourcing-projections.html">Projections</a></li>
      <li><a href="https://dzone.com/articles/the-ugly-of-event-sourcing-projection-schema-chang">The Ugly of Event Sourcing</a></li>
      <li><a href="https://abdullin.com/post/event-sourcing-projections/">Projections</a></li>
    </ul>

    <h3>Log-Based Architecture</h3>
    <ul>
      <li><a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">The Log (Jay Kreps)</a></li>
      <li><a href="https://www.confluent.io/blog/okay-store-data-apache-kafka/">Store Data in Kafka</a></li>
      <li><a href="https://www.confluent.io/blog/publishing-apache-kafka-new-york-times/">New York Times uses log-based architecture with Kafka</a></li>
    </ul>

    <h3>2PC</h3>
    <ul>
      <li>The objective of the 2 phase-commit (2PC) is to have a single ACID transaction on multiple nodes, whatever happens (read: failure and partition). So we have a distributed system with multiple databases and multiple clients. These clients can do simple transactions--going to a single node--or distributed transactions--going to multiple nodes. Transactions going on multiple nodes will use the 2PC protocol.</li>
      <li>The traditional solution is 2PC (a.k.a. distributed transactions) but this is not a viable technology for modern applications. The CAP theorem requires you to chose between availability and consistency, and availability is usually the better choice. Moreover, many modern technologies, such as most NoSQL databases, do not even support ACID transactions let alone, 2PC.</li>
    </ul>
  </body>
</html>